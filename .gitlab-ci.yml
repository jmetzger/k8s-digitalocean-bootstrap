##
stages:
  - deploy
  - helm
  - destroy

variables:
  TF_ROOT: "terraform"
  HELM_ROOT: "helm/ingress"

terraform:
  image: 
    name: hashicorp/terraform:1.8
    entrypoint: [""]
  stage: deploy
  script:
    - export TF_VAR_do_token=$DIGITALOCEAN_ACCESS_TOKEN
    - cd $TF_ROOT
    - terraform init
    - |
      if ! terraform apply -auto-approve; then
        echo "‚ö†Ô∏è Terraform apply failed, checking if cluster already exists..."
        CLUSTER_ID=$(curl -s -H "Authorization: Bearer $DIGITALOCEAN_ACCESS_TOKEN" \
          "https://api.digitalocean.com/v2/kubernetes/clusters" | \
          jq -r '.kubernetes_clusters[] | select(.name=="gitlab-cluster") | .id')
        
        if [ -n "$CLUSTER_ID" ] && [ "$CLUSTER_ID" != "null" ]; then
          echo "üì• Found existing cluster with ID: $CLUSTER_ID"
          echo "üîÑ Importing cluster into Terraform state..."
          terraform import digitalocean_kubernetes_cluster.main $CLUSTER_ID
          echo "‚úÖ Import successful, running terraform apply again..."
          terraform apply -auto-approve
        else
          echo "‚ùå No existing cluster found, terraform apply failed for other reasons"
          exit 1
        fi
      fi
    - terraform output -raw kubeconfig > kubeconfig
  artifacts:
    paths:
      - terraform/kubeconfig
    expire_in: 1 hour

upload-kubeconfig:
  image: curlimages/curl
  stage: deploy
  script:
    - echo "Uploading kubeconfig as GitLab CI/CD variable..."
    - |
      curl --request POST         --header "PRIVATE-TOKEN: $GITLAB_PAT_KUBECONFIG"         --form "key=KUBECONFIG"         --form "value=$(cat terraform/kubeconfig)"         --form "masked=true"         https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/variables
  needs: ["terraform"]

helm:
  image: 
    name: alpine/k8s:1.33.1
    entrypoint: [""]
  stage: helm
  script:
    - apk add curl bash
    - export KUBECONFIG=$CI_PROJECT_DIR/terraform/kubeconfig
    - helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
    - helm repo add jetstack https://charts.jetstack.io
    - helm repo update
    - helm upgrade --install ingress ingress-nginx/ingress-nginx --namespace ingress-nginx --create-namespace -f $HELM_ROOT/values.yaml
    - helm upgrade --install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace -f helm/cert-manager-values.yaml
    - echo "Warte auf LoadBalancer-IP..."
    - LB_IP=$(kubectl get svc ingress-ingress-nginx-controller -n ingress-nginx -o json --watch | jq -r 'select(.status.loadBalancer.ingress[0].ip != null) | .status.loadBalancer.ingress[0].ip' | head -n 1)
    - echo "LoadBalancer IP: $LB_IP"
    - echo "$LB_IP" > lb_ip.txt
    - echo "Erstelle DNS-Record f√ºr *.auto.do.t3isp.de..."
    - |
      DNS_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST -H "Content-Type: application/json" \
        -H "Authorization: Bearer $DIGITALOCEAN_ACCESS_TOKEN" \
        -d "{\"type\":\"A\",\"name\":\"*.auto\",\"data\":\"$LB_IP\",\"ttl\":300}" \
        "https://api.digitalocean.com/v2/domains/t3isp.de/records")
      HTTP_STATUS=$(echo $DNS_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
      DNS_BODY=$(echo $DNS_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')
      if [ "$HTTP_STATUS" -eq 201 ] || [ "$HTTP_STATUS" -eq 200 ]; then
        echo "‚úÖ DNS-Record erfolgreich erstellt: $DNS_BODY"
      else
        echo "‚ùå Fehler beim Erstellen des DNS-Records!"
        echo "HTTP Status: $HTTP_STATUS"
        echo "Response: $DNS_BODY"
        exit 1
      fi
    - echo "Erstelle Testapp Namespace..."
    - kubectl create namespace testapp --dry-run=client -o yaml | kubectl apply -f -
    - echo "Deploye Testapp..."
    - kubectl apply -f manifests/testapp/
  needs: ["terraform"]

destroy:
  image: hashicorp/terraform:1.8
  stage: destroy
  script:
    - cd terraform
    - terraform init
    - terraform destroy -auto-approve
  when: manual
  only:
    - main

